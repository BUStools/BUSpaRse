#' @include tr2g.R
NULL

#' Convert Latin species name to dataset name
#' 
#' This function converts Latin species name to a dataset name in biomart to
#' query gene and transcript ID.
#' 
#' @inheritParams transcript2gene
#' @return The appropriate dataset name for biomart.
#' @export
species2dataset <- function(species) { 
  species <- strsplit(species, " ")[[1]]
  if (length(species) != 2) {
    stop("Please use the Latin binomial convention for species rather than the colloquial name.\n")
  }
  species[1] <- tolower(substr(species[1], 1, 1))
  species <- paste(species, collapse = "")
  paste(species, "gene", "ensembl", sep = "_")
}

#' Check that a tag is present in attribute field of GTF/GFF
#' 
#' The attribute field of GTF/GFF files are very complicated and is very
#' inconsistent between sources. This function is to make sure that transcript 
#' and gene IDs can be extracted properly.
#' 
#' @param tags_use The tags to be checked.
#' @param tags The tags present in attribute field.
#' @return Error or warning if tag is absent.
check_tag_present <- function(tags_use, tags, error = TRUE) {
  present <- tags_use %in% tags
  if (!all(present)) {
    s <- paste("Tags", paste(tags_use[!present], collapse = ", "), 
               "are absent from the attribute field.\n")
    if (error) {
      stop(s)
    } else {
      warning(paste(s, "These tags are ignored.\n"))
    }
  }
}

#' Check that an object is a character vector of length 1
#' 
#' Just in case the user passes something with length more than 1 and messes up
#' everything thanks to vectorization.
#' 
#' @param x Named vector of arguments to be checked.
#' @return Error if \code{x} is not a character vector with length 1.
check_char1 <- function(x) {
  arg_names <- names(x)
  inds <- !is.character(x) | length(x) > 1
  if (any(inds)) {
    stop(paste(paste(arg_names[inds], sep = ", "), 
               "must be a character vector with length 1.\n"))
  }
}

#' Check inputs to tr2g_gtf and tr2g_gff3
#' 
#' This function validates inputs to tr2g_gtf and tr2g_gff3 and throws error
#' early if some inputs are wrong.
#' 
#' @inheritParams tr2g_gtf
#' @param format Whether it's gtf or gff3.
#' @return Nothing, will throw error if there's a problem.

check_gff <- function(format, file, transcript_id, gene_id, gene_name,
                      transcript_version, gene_version, version_sep) {
  if (is.null(transcript_id)) stop("transcript_id cannot be NULL.\n")
  if (is.null(gene_id)) stop("gene_id cannot be NULL.\n")
  
  if (!str_detect(file, paste0("\\.", format))) {
    stop(paste("file must be a", toupper(format), "file.\n"))
  }
}

#' Save sparse matrix in CellRanger \code{mtx} format
#' 
#' This function saves the sparse matrix generated by \code{\link{make_sparse_matrix}},
#' \code{\link{busparse_gene_count}} in the CellRanger output format. The sparse
#' matrix itself will be saved as \code{matrix.mtx}. Barcodes will be saved as
#' \code{barcodes.tsv}. Gene names (for gene count matrices) or ECs (for TCC 
#' matrices) will be saved as \code{features.tsv}. The purpose of this function 
#' is interoperability, so coworkers who do not use R can load the output of 
#' this package for downstream analysis.
#' 
#' @param mat The sparse matrix, as \code{\link[Matrix]{dgCMatrix-class}}.
#' @param out_path Path to directory to save the file. If the directory does not
#' exist, then it will be created.
#' @param compress Logical, whether to compress the output files. If \code{TRUE},
#' then each file will be compressed individually. The directory containing the
#' files will not be compressed as a whole.
#' @param compression_level Compression level for gzip.
#' @return Nothing is returned into the R session; the files are written on disk.
#' @importFrom Matrix writeMM
#' @export
#' 
save_cellranger <- function(mat, out_path, compress = TRUE, 
                            compression_level = 6) {
  if (!is(mat, "dgCMatrix")) {
    stop("mat must be a dgCMatrix.\n")
  }
  out_path <- normalizePath(out_path)
  if (!dir.exists(out_path)) dir.create(out_path)
  mat_fn <- paste(out_path, "matrix.mtx", sep = "/")
  f_fn <- paste(out_path, "features.tsv", sep = "/")
  b_fn <- paste(out_path, "barcodes.tsv", sep = "/")
  writeMM(mat, mat_fn)
  writeLines(rownames(mat), f_fn)
  writeLines(colnames(mat), b_fn)
  if (compress) {
    gzfile(mat_fn, compression = compression_level)
    gzfile(f_fn, compression = compression_level)
    gzfile(b_fn, compression = compression_level)
  }
}
