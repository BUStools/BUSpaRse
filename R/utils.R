#' @include tr2g.R
NULL

#' Convert Latin species name to dataset name
#' 
#' This function converts Latin species name to a dataset name in biomart to
#' query gene and transcript ID.
#' 
#' @inheritParams transcript2gene
#' @return The appropriate dataset name for biomart.
#' @export
species2dataset <- function(species) { 
  species <- strsplit(species, " ")[[1]]
  if (length(species) != 2) {
    stop("Please use the Latin binomial convention for species rather than the colloquial name.\n")
  }
  species[1] <- tolower(substr(species[1], 1, 1))
  species <- paste(species, collapse = "")
  paste(species, "gene", "ensembl", sep = "_")
}

#' Check that a tag is present in attribute field of GTF/GFF
#' 
#' The attribute field of GTF/GFF files are very complicated and is very
#' inconsistent between sources. This function is to make sure that transcript 
#' and gene IDs can be extracted properly.
#' 
#' @param tags_use The tags to be checked.
#' @param tags The tags present in attribute field.
#' @param error Whether to throw an error for absent tags. If \code{FALSE}, then
#' a warning will be given.
#' @return Error or warning if tag is absent.
check_tag_present <- function(tags_use, tags, error = TRUE) {
  present <- tags_use %in% tags
  if (!all(present)) {
    s <- paste("Tags", paste(tags_use[!present], collapse = ", "), 
               "are absent from the attribute field.\n")
    if (error) {
      stop(s)
    } else {
      warning(paste(s, "These tags are ignored.\n"))
    }
  }
}

#' Check that an object is a character vector of length 1
#' 
#' Just in case the user passes something with length more than 1 and messes up
#' everything thanks to vectorization.
#' 
#' @param x Named vector of arguments to be checked.
#' @return Error if \code{x} is not a character vector with length 1.
check_char1 <- function(x) {
  arg_names <- names(x)
  inds <- !is.character(x) | length(x) > 1
  if (any(inds)) {
    stop(paste(paste(arg_names[inds], sep = ", "), 
               "must be a character vector with length 1.\n"))
  }
}

#' Check inputs to tr2g_gtf and tr2g_gff3
#' 
#' This function validates inputs to tr2g_gtf and tr2g_gff3 and throws error
#' early if some inputs are wrong.
#' 
#' @inheritParams tr2g_gtf
#' @param format Whether it's gtf or gff3.
#' @return Nothing, will throw error if there's a problem.

check_gff <- function(format, file, transcript_id, gene_id, gene_name,
                      transcript_version, gene_version, version_sep) {
  if (is.null(transcript_id)) stop("transcript_id cannot be NULL.\n")
  if (is.null(gene_id)) stop("gene_id cannot be NULL.\n")
  
  if (!str_detect(file, paste0("\\.", format))) {
    stop(paste("file must be a", toupper(format), "file.\n"))
  }
}

#' Save sparse matrix in CellRanger \code{mtx} format
#' 
#' This function saves the sparse matrix generated by \code{\link{make_sparse_matrix}},
#' \code{\link{busparse_matrix}} in the CellRanger output format. The sparse
#' matrix itself will be saved as \code{matrix.mtx}. Barcodes will be saved as
#' \code{barcodes.tsv}. Gene names (for gene count matrices) or ECs (for TCC 
#' matrices) will be saved as \code{features.tsv}. The purpose of this function 
#' is interoperability, so coworkers who do not use R can load the output of 
#' this package for downstream analysis.
#' 
#' @param mat The sparse matrix, as \code{\link[Matrix]{dgCMatrix-class}}.
#' @param out_path Path to directory to save the file. If the directory does not
#' exist, then it will be created.
#' @param compress Logical, whether to compress the output files. If \code{TRUE},
#' then each file will be compressed individually. The directory containing the
#' files will not be compressed as a whole.
#' @param compression_level Compression level for gzip.
#' @return Nothing is returned into the R session; the files are written on disk.
#' @importFrom Matrix writeMM
#' @importFrom R.utils gzip
#' @importFrom methods is
#' @export
#' 
save_cellranger <- function(mat, out_path, compress = TRUE, 
                            compression_level = 6) {
  if (!is(mat, "dgCMatrix")) {
    stop("mat must be a dgCMatrix.\n")
  }
  out_path <- normalizePath(out_path, mustWork = FALSE)
  if (!dir.exists(out_path)) dir.create(out_path)
  mat_fn <- paste(out_path, "matrix.mtx", sep = "/")
  f_fn <- paste(out_path, "features.tsv", sep = "/")
  b_fn <- paste(out_path, "barcodes.tsv", sep = "/")
  writeMM(mat, mat_fn)
  writeLines(rownames(mat), f_fn)
  writeLines(colnames(mat), b_fn)
  if (compress) {
    gzip(mat_fn, compression = compression_level)
    gzip(f_fn, compression = compression_level)
    gzip(b_fn, compression = compression_level)
  }
}

#' Check for existence of file that may be compressed
#' 
#' Functions like `fread` can directly read gzipped files, so there's no need to
#' decompress. This function checks if a file exists, and if it doesn't, whether
#' its gzipped counterpart exists.
#' 
#' @param fn Path to the file.
#' @return The path itself if the file exists, the path with gz extension if the
#' gzipped version exists, and an error if neither exists.
#' 
check_file_gz <- function(fn) {
  if (!file.exists(fn)) {
    if (file.exists(paste(fn, "gz", sep = "."))) {
      return(paste(fn, "gz", sep = "."))
    } else {
      stop("File ", fn, " doesn't exist.")
    }
  } else {
    return(fn)
  }
}

#' Read sparse matrix from CellRanger format
#' 
#' This function reads `matrix.mtx`, `features.tsv`, and `barcodes.tsv`. The 
#' files can be gzipped for compression, and supplied to this function without
#' decompression. 
#' 
#' @param out_path Directory where `matrix.mtx`, `features.tsv`, and `barcodes.tsv`
#' are saved.
#' @return A dgCMatrix as in `matrix.mtx` with contents of `features.tsv` as
#' row names and contents of `barcodes.tsv` as column names.
#' @importFrom Matrix readMM
#' @importFrom methods as
#' @export
#' 
read_cellranger <- function(out_path) {
  out_path <- normalizePath(out_path, mustWork = TRUE)
  mat_fn <- paste(out_path, "matrix.mtx", sep = "/")
  f_fn <- paste(out_path, "features.tsv", sep = "/")
  b_fn <- paste(out_path, "barcodes.tsv", sep = "/")
  mat_fn <- check_file_gz(mat_fn)
  f_fn <- check_file_gz(f_fn)
  b_fn <- check_file_gz(b_fn)
  mat_read <- readMM(mat_fn)
  # Convert to dgCMatrix
  mat_read <- as(mat_read, "dgCMatrix")
  gn <- fread(f_fn, header = FALSE)$V1
  bc <- fread(b_fn, header = FALSE)$V1
  rownames(mat_read) <- gn
  colnames(mat_read) <- bc
  return(mat_read)
}
